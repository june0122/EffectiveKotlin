# 아이템 20. 일반적인 알고리즘을 반복해서 구현하지 말라

많은 개발자는 같은 알고리즘을 여러 번 반복해서 구현합니다. 여기에서 말하는 알고리즘은 특정 프로젝트에 국한된 것이 아니라 수학적인 연산, 수집 처리처럼 별도의 모듈 또는 라이브러리로 분리할 수 있는 부분을 의미합니다.

물론 매우 복잡한 알고리즘도 있겠지만 아래의 코드와 같이 숫자를 특정 범위에 맞추는 간단한 알고리즘도 있을 수 있습니다.

```kotlin
val parcent = when {
    numberFromUser > 100 -> 100
    numberFromUser < 0 -> 0
    else -> numberFromUser
}
```

이 알고리즘은 사실 stdlib의 `coreceIn` 확장 함수로 이미 존재하기 때문에 따로 구현하지 않아도 됩니다.

```kotlin
val percent = numberFromUser.coreceIn(0, 100)
```

이처럼 이미 있는 것을 활용하면, 단순하게 코드가 짧아진다는 것 이외에도 다양한 장점이 있습니다.

- 코드 작성 속도가 빨라집니다. 호출을 한 번 하는 것이 알고리즘을 만드는 것보다 빠릅니다.
- 구현을 따로 읽지 않아도 함수의 이름 등만 보고도 무엇을 하는지 확실하게 알 수 있습니다.
- 직접 구현할 때 발생할 수 있는 실수를 줄일 수 있습니다.
  - 정렬을 하는 `sortedBy`와 `sortedByDesending`을 생각해보면 두 함수의 내부 설계가 거의 비슷하지만, 정렬 방향이 반대입니다. 이러한 로직을 직접 반복적으로 구현해보면 작성한 코드의 정렬 순서가 오름차순인지 내림차순인지 헷갈리게 되는 경우가 많습니다. 알고리즘 구현 앞에 주석을 달 수도 있겠지만, 사실 이는 큰 도움이 되지 않습니다. 통계적으로 개발자는 코드를 업데이트하고 나서 이전의 주석을 거의 변경하지 않습니다. 그래서 주석은 시간이 갈수록 신뢰를 잃기 때문에 크게 살펴보지 않게 됩니다.
- 제작자들이 한 번만 최적화하면, 이러한 함수를 활용하는 모든 곳이 최적화의 혜택을 받을 수 있습니다.

### 표준 라이브러리 살펴보기

일반적인 알고리즘은 대부분 이미 다른 사람들이 정의해 놓았습니다. 그중에서 가장 대표적인 라이브러리는 바로 표준 라이브러리인 stdlib입니다. stdlib은 확장 함수를 활용해서 만들어진 굉장히 거대한 유틸리티 라이브러리입니다. stdlib의 함수들을 하나하나 살펴보는 것은 굉장히 어려울 수 있지만, 그럴만한 가치가 있는 일입니다. 만약 자세히 살펴보지 않으면, 계속해서 같은 함수를 여러 번 만들게 될 것입니다.

### 나만의 유틸리티 구현하기

상황에 따라서 표준 라이브러리에 없는 알고리즘이 필요할 수도 있습니다. 예를 들어 컬렉션에 있는 모든 숫자의 곱을 계산하는 라이브러리가 필요하다면 어떻게 해야 할까요? 이는 널리 알려진 추상화이므로 범용 유틸리티 함수<small>(universal utility function)</small>로 정의하는 것이 좋습니다.

```kotlin
fun Iterable<Int>.product() = 
    fold(1) { acc, i -> acc * i }
```

여러 번 사용되지 않는다고 해도 이렇게 만드는 것이 좋습니다. 이는 잘 알려진 수학적 개념이고, *product*라는 이름이 숫자를 곱할 거라는 것은 대부분의 개발자들이 예측할 수 있기 때문입니다. 이후에 다른 개발자가 컬렉션의 숫자를 곱하는 함수를 만들어야 할 때, 이렇게 이미 구현되어 있다면 기쁠 것입니다.

동일한 결과를 얻는 함수를 여러 번 만드는 것은 잘못된 일입니다. 모든 함수는 테스트되어야 하고, 기억되어야 하며, 유지보수되어야 합니다. 따라서 함수를 만들 때는 이러한 비용이 들어갈 수 있다는 것을 전제해야 합니다. 따라서 필요 없는 함수를 중복해서 만들지 않게, 기존에 관련된 함수가 있는지 탐색하는 과정이 필요합니다.

코틀린 stdlib에 정의된 대부분의 함수처럼, 앞 코드의 *product*도 확장 함수로 구현되어 있습니다. 많이 사용되는 알고리즘을 추출하는 방법으로는 톱레벨 함수, 프로퍼티 위임, 클래스 등이 있습니다. **확장 함수는 이러한 방법들과 비교해서 다음과 같은 장점을 가지고 있습니다.**

- 함수는 상태를 유지하지 않으므로, 행위를 나타내기 좋습니다. 특히 부가작용<small>(side-effect)</small>이 없는 경우에는 더 좋습니다.
- 톱레벨 함수와 비교해서, 확장 함수는 구체적인 타입이 있는 객체에만 사용을 제한할 수 있으므로 좋습니다.
- 수정할 객체를 아규먼트로 전달받아 사용하는 것보다는 확장 리시버로 사용하는 것이 가독성 측면에서 좋습니다.
- 확장 함수는 객체에 정의한 함수보다 객체를 사용할 때, 자동 완성 기능 등으로 제안이 이루어지므로 쉽게 찾을 수 있습니다.
  - `TextUtils.isEmpty("text")` 보다는 `"Text".isEmpty()`가 더 사용하기 쉽습니다.

### 정리

일반적인 알고리즘을 반복해서 만들지 말아 주세요. 우선 대부분 stdlib에 이미 정의되어 있을 가능성이 높습니다. 따라서 stdlib을 공부해두면 좋습니다. stdlib에 없는 일반적인 알고리즘이 필요하거나, 특정 알고리즘을 반복해서 사용해야 하는 경우에는 프로젝트 내부에 직접 정의하기 바랍니다. **일반적으로 이런 알고리즘들은 확장 함수로 정의하는 것이 좋습니다.**