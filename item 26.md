# 아이템 26. 함수 내부의 추상화 레벨을 통일하라

계층이 잘 분리될 경우
- 어떤 계층에서 작업할 때 그 아래의 계층은 이미 완성되어 있으므로, 해당 계층만 생각하면 됨
- 전체를 이해할 필요가 없어짐
- ex) 어셈블리 언어, JVM 바이트 코드가 무엇인지 몰라도 프로그래밍 가능

개발자는 일반적으로 특정한 계층에서 작업하며, 가끔 그 위에 추가로 계층을 올려서 사용합니다. 계층이 잘 나뉘어져 있어서, 개발자는 여기까지만 알아도 되는 것입니다.

### 추상화 레벨

프로그래밍에서는 일반적으로 높은 레벨일수록 프로세서로부터 멀어진다고 표현합니다. 높은 레벨일수록 걱정해야 하는 세부적인 내용들이 적습니다. 하지만 무엇이든 무조건 좋을 수는 없습니다.

높은 레벨일수록 단순함을 얻지만, 제어력<small>(control)</small>을 잃습니다.
- C언어는 메모리를 직접 관리 가능
- 자바는 가비지 컬렉터가 자동으로 메모리를 관리해주기에, 메모리 사용을 최적화하는 것이 굉장히 힘듦

### 추상화 레벨 통일

컴퓨터 사이언스와 마찬가지로 코드도 추상화를 계층처럼 만들어서 사용할 수 있습니다. 이를 위한 기본적인 도구가 바로 함수입니다. 컴퓨터 사이언스가 높은 레벨과 낮은 레벨을 확실하게 구분하고 있는 것처럼, 함수도 높은 레벨과 낮은 레벨을 구분해서 사용해야 한다는 원칙이 있습니다. 이를 <b>추상화 레벨 통일<small>(Single Level of Abstraction, SLA)</small></b> 원칙이라고 부릅니다.

함수는 간단해야 합니다.
- 이는 *'함수는 작아야하며, 최소한의 책임만을 가져야 한다'*라는 일반적인 규칙
- 어떤 함수가 다른 함수보다 좀 복잡하다면, 일부 부분을 추출해서 추상화<small>(`item 27`)</small>하는 것이 좋습니다.
- 모든 추상화 레벨에서 '추상 요소<small>(abstract term)</small>'<small>(메서드 또는 클래스)</small>를 조작합니다.
- 각자의 추상 요소가 어떤 내용을 담고 있는지 확인하고 싶다면, 정의로 이동해서 확인하면 됩니다.
- 추가적으로 이런 형태로 함수를 추출하면, 재사용과 테스트가 쉬워집니다.
- 또한 함수가 작아져 단위 테스트도 쉽습니다.

### 프로그램 아키텍처의 추상 레벨

추상화 계층이라는 개념은 함수보다 높은 레벨에서도 적용할 수 있습니다. 추상화를 구분하는 이유는 서브시스템의 세부 사항을 숨김으로써 상호 운영성<small>(interoperability)</small>과 플랫폼 독립성을 얻기 위함입니다. 이는 문제 중심으로 프로그래밍한다는 의미입니다.

이러한 개념은 모듈 시스템<small>(modular system)</small>을 설계할 때도 중요합니다. 모듈을 분리하면 계층 고유의 요소를 숨길 수 있습니다. 애플리케이션을 만들 때는 입력과 출력을 나타내는 모듈<small>(FE의 뷰, BE의 HTTP 요청 처리 등)</small>은 낮은 레벨의 모듈입니다. 그리고 비즈니스 로직을 나타내는 부분이 높은 레벨의 모듈입니다.

계층이 잘 분리된 프로젝트를 계층화가 잘 되었다고 부릅니다. 계층화가 잘 된 프로젝트를 좋은 프로젝트라고 부릅니다. 계층화가 잘 된 프로젝트는 어떤 계층 위치에서 코드를 보아도, 일관적인 관점을 얻을 수 있습니다.

### 정리

별도의 추상화 계층을 만드는 것은 프로그래밍에서 일반적으로 사용되는 개념입니다. 이는 knowledge를 체계화하고, 서브시스템의 세부 사항을 숨김으로써 상호 운영성<small>(interoperability)</small>과 플랫폼 독립성을 얻게 합니다. 함수, 클래스, 모듈 등의 다양한 방식을 통해서 추상화를 분리합니다. 이때 각각의 레이어가 너무 커지는 것은 좋지 않습니다. 작고 최소한의 책임만 갖는 함수가 이해하기 쉽습니다. 추상화 레벨은 구체적인 동작, 프로세서, 입출력과 가까울수록 낮은 레벨이라고 표현합니다. 낮은 추상화 계층에서는 높은 계층에서 사용하는 요소<small>(API)</small>를 만듭니다.