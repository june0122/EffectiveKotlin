# 아이템 33. 생성자 대신 팩토리 함수를 사용하라

클라이언트가 클래스의 인스턴스를 만들게 하는 가장 일반적인 방법은 기본 생성자<small>(primary constructor)</small>를 사용하는 방법입니다.

하지만 생성자가 객체를 만들 수 있는 유일한 방법은 아닙니다. 디장니 패턴으로 굉장히 다양한 생성 패턴<small>(creational pattern)</small>들이 만들어져 있습니다. 일반적으로 이러한 생성 패턴은 객체를 생성자로 직접 생성하지 않고, 별도의 함수를 통해 생성합니다.

생성자의 역할을 대신해주는 함수를 **팩토리 함수**라고 부릅니다. 생성자 대신에 팩토리 함수를 사용하면 다양한 장점들이 생깁니다.

- 생성자와 다르게, 함수에 이름을 붙일 수 있습니다.
  - 이름은 객체가 생성되는 방법과 아규먼트로 무엇이 필요한지 설명할 수 있기에 훨씬 이해하기가 쉽습니다.
  - 동일한 파라미터 타입을 갖는 생성자의 충돌을 줄일 수 있습니다.
- 생성자와 다르게, 함수가 원하는 형태의 타입을 리턴할 수 있습니다.
  - 따라서 다른 객체를 생성할 때 사용할 수 있습니다.
  - 인터페이스 뒤에 실제 객체의 구현을 숨길 때 유용하게 사용할 수 있습니다.
    - 인터페이스를 리턴하면, 인터페이스만 지켜서 만들어진다면 어떤 클래스라도 잘 동작할 것입니다.
    - 따라서 코틀린 제작자가 더 많은 자유를 가질 수 있습니다.
- 생성자와 다르게, 호출될 때마다 새 객체를 만들 필요가 없습니다.
  - 함수를 사용해서 객체를 생성하면 싱글턴 패턴처럼 객체를 하나만 생성하게 강제하거나, 최적화를 위해 캐싱 매커니즘을 사용할 수도 있습니다.
  - 객체를 만들 수 없을 경우, null을 리턴하게 만들 수도 있습니다.
    - `Connection.createOrNull()` : 어떠한 이유로 연결을 생성할 수 없을 때 null을 리턴
- 팩토리 함수는 아직 존재하지 않는 객체를 리턴할 수도 있습니다.
  - 이러한 특징 때문에 어노테이션 처리를 기반으로 하는 라이브러리에서는 팩토리 함수를 많이 사용합니다.
  - 이를 활용하면 프로젝트를 빌드하지 않고도 앞으로 만들어질 객체를 사용하거나, 프록시를 통해 만들어지는 객체를 사용할 수 있습니다.
- 객체 외부에 팩토리 함수를 만들면, 그 가시성을 원하는 대로 제어할 수 있습니다.
  - 예를 들어, 톱레벨 팩토리 함수를 같은 파일 또는 같은 모듈에서만 접근하게 만들 수 있습니다.
- 팩토리 함수는 인라인으로 만들 수 있으며, 그 파라미터들을 `reified`로 만들 수 있습니다.
- 팩토리 함수는 생성자로 만들기 복잡한 객체도 만들어 낼 수 있습니다.
- 생성자는 즉시 슈퍼클래스 또는 기본 생성자를 호출해야 합니다. 하지만 팩토리 함수를 사용하면, 원하는 때에 생성자를 호출할 수 있습니다.

다만 팩토리 함수로 클래스를 생성할 때는 서브클래스 생성에는 슈퍼클래스의 생성자가 필요하기 때문에, 서브클래스를 만들어낼 수 없다는 약간의 제한이 발생합니다. 하지만 아무런 문제가 되지 않습니다. 팩토리 함수로 슈퍼클래스를 만들기로 했다면, 그 서브클래스에도 팩토리 함수를 만들면 됩니다.

```kotlin
class MyLinkedIntList(head: Int, tail: MyLinkedIntList?) : MyLinkedList<Int>(head, tail)

fun myLinkedIntListOf(vararg elements: Int): MyLinkedIntList? {
	if (elements.isEmpty()) return null
	val head = elements.first()
	val elementsTail = elements.copyOfRange(1, elements.size)
	val tail = myLinkedIntListOf(*elementsTail)
	return MyLinkedIntList(head, tail)
}
```

위의 코드에서 앞의 생성자는 이전 생성자보다 길지만, 유연성, 클래스 독립성, nullable을 리턴하는 등의 다양한 특징을 갖습니다.

팩토리 함수는 굉장히 강력한 객체 생성 방법입니다.
- 이 말을 들으면, 기본 생성자 또는 팩토리 함수 중에 양자택일을 해야 한다고 이해할 수도 있는데, 기본 생성자를 사용하지 말라는 말이 아닙니다.
- 팩토리 함수 내부에서는 생성자를 사용해야 합니다.
- 일반적인 자바로 팩토리 패턴을 구현할 때는 생성자를 private로 만들지만, 코틀린에서는 그렇게 하는 경우가 거의 없습니다<small>(`아이템 34: 기본 생성자에 이름 있는 옵션 아규먼트를 사용하라` 참고)</small>.
- 팩토리 함수는 기본 생성자가 아닌 추가적인 생성자<small>(secondary constructor)</small>와 경쟁 관계입니다.
- 여러 코틀린 프로젝트를 살펴보면, 추가적인 생성자보다는 팩토리 함수를 많이 사용합니다. 또한 팩토리 함수는 다른 종류의 팩토리 함수와 경쟁 관계에 있다고 할 수 있습니다.

#### 팩토리 함수의 종류

1. companion 객체 팩토리 함수
2. 확장 팩토리 함수
3. 톱레벨 팩토리 함수
4. 가짜 생성자
5. 팩토리 클래스의 메서드
