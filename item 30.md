# 아이템 30. 요소의 가시성을 최소화하라

API를 설계할 때 가능한 한 간결한 API를 선호하는 데는 여러 가지 이유가 있습니다. 가장 중요한 몇 가지 이유를 살펴보도록 합시다.

작은 인터페이스는 배우기 쉽고 유지하기 쉽습니다. 기능이 많은 클래스보다는 적은 클래스를 이해하는 것이 쉽습니다. 또한 유지보수하기도 쉽습니다. 일반적으로 어떤 수정을 가하기 위해서는 클래스 전체를 이해하고 있어야 합니다. 보이는 요소 자체가 적다면, 유지보수하고 테스트할 것이 적습니다.

변경을 가할 때는 기존의 것을 숨기는 것보다 새로운 것을 노출하는 것이 쉽습니다. 일반적으로 공개적으로 노출되어 있는 요소들은 이미 외부에서 사용되고 있을 것입니다. 그래서 이런 요소들을 변경하면, 이 코드를 사용하는 모든 부분이 영향을 받습니다. 가시성과 관련된 제한을 변경하는 것은 더 어렵습니다. 이러한 변경은 신중하게 고려해야 하며, 변경할 경우에는 대체재를 제공해야 합니다. 다만 다른 개발자가 구현한 코드에 대한 대체재를 제공하는 것은 굉장히 어려울 수 있습니다. 비즈니스 요구 사항이 무엇인지 빠르게 파악하기 어려울 수 있기 때문입니다. 널리 사용되는 공개 라이브러리라면, 일부 요소의 가시성을 제한한 경우 여러 사용자가 분노할 수 있습니다. 따라서 처음에는 작은 API로서 개발을 하도록 강제하는 것이 더 좋을 수 있습니다.

클래스의 상태를 나타내는 프로퍼티를 외부에서 변경할 수 있다면, 클래스는 자신의 상태를 보장할 수 없습니다. 클래스가 만족해야 하는 클래스의 상태에 대한 규약 등이 있을 수 있습니다. 이러한 규약을 모르는 사람은 클래스의 상태를 마음대로 변경할 수 있으므로, 클래스의 불변성<small>(invariant)</small>이 무너질 가능성이 있습니다. 2장에서 살펴보았던 `CounterSet`을 다시 살펴봅시다. 이 코드에서 `elementsAdded`의 세터를 *private*로 설정했었습니다. 이 부분이 없다면 외부에서 이 코드를 강제로 바꿀 수 있고, 이 프로퍼티에 대한 신뢰성에 문제가 생길 수 있습니다. 이처럼 세터만 *private*으로 만드는 코드는 굉장히 많이 사용되므로 기억해 주세요.

```kotlin
class CounterSet<T>(
    private val innerSet: MutableSet<T> = setOf()
) : MutableSet<T> by innerSet {

    var elementsAdded: Int = 0
        private set

    override fun add(element: T): Boolean {
        elementsAdded++
        return innerSet.add(element)
    }

    override fun addAll(elements: Collection<T>): Boolean {
        elementsAdded += elements.size
        return innerSet.addAll(elements)
    }
} 
```

일반적으로 코틀린에서는 이처럼 구체 접근자의 가시성을 제한해서 모든 프로퍼티를 캡슐화하는 것이 좋습니다.

서로서로 의존하는 프로퍼티가 있을 때는 객체 상태를 보호하는 것이 더 중요해집니다. 예를 들어 mutableLazy 델리게이트를 구현할 때를 생각해 봅시다. 이는 initialized가 true라면 값 초기화가 이루어지고, 이때의 값은 T 타입이라는 것을 예상할 수 있습니다. 이때 initialized의 세터가 노출되어서는 안됩니다. 이것이 노출되면 예상하지 못한 변경에 의해서 예외가 발생하고, 코드의 신뢰성이 떨어질 수 있기 때문입니다.

```kotlin
class MutableLazyHolder<T>(val initailizer: () -> T) {
    
    private var value: Any = Any()
    private var initialized = false

    override fun get(): T {
        if (!initialized) {
            value = initializer()
            initialized = true
        }
        return value as T
    }

    override fun setValue() {
        this.value = value
        initialized = true
    }
}
```

가시성이 제한될수록 클래스의 변경을 쉽게 추적할 수 있으며, 프로퍼티 상태를 더 쉽게 이해할 수 있습니다. 이는 동시성<small>(concurrency)</small>을 처리할 때 중요합니다. 상태 변경은 병렬 프로그래밍에서 문제가 됩니다. 따라서 많은 것을 제한할수록 병렬 프로그래밍을 할 때 안전해집니다.

### 가시성 한정자 사용하기

내부적인 변경 없이 작은 인터페이스를 유지하고 싶다면, 가시성<small>(visibility)</small>을 제한하면 됩니다. 기본적으로 클래스와 요소를 외부에 노출할 필요가 없다면, 가시성을 제한해서 외부에서 접근할 수 없게 만드는 것이 좋습니다. 가시성 제한은 가시성 한정자<small>(visibility modifier)</small>를 활용해서 구현합니다.

클래스 멤버의 경우 다음과 같은 4개의 가시성 한정자를 사용할 수 있습니다.

- public(디폴트): 어디에서나 볼 수 있습니다.
- private: 클래스 내부에서만 볼 수 있습니다.
- protected: 클래스와 서브클래스 내부에서만 볼 수 있습니다.
- internal: 모듈 내부에서만 볼 수 있습니다.

톱레벨 요소에는 세 가지 가시성 한정자를 사용할 수 있습니다.

- public(디폴트): 어디에서나 볼 수 있습니다.
- private: 같은 파일 내부에서만 볼 수 있습니다.
- internal: 모듈 내부에서만 볼 수 있습니다.

참고로 모듈과 패키지를 혼동하는 개발자들이 있는데, 의미가 전혀 다릅니다. 코틀린에서 모듈이란 함께 컴파일되는 코틀린 소스를 의미합니다. 따라서 다음을 의미합니다.

- Gradle 소스 세트
- Maven 프로젝트
- IntelliJ IDEA 모듈
- Ant 태스크 한 번으로 컴파일되는 파일 세트

### 정리

요소의 가시성은 최대한 제한적인 것이 좋습니다. 보이는 요소들은 모두 public API로 사용되며, 다음과 같은 이유로 최대한 단순한 것이 좋습니다.

- 인터페이스가 작을수록 이를 공부하고 유지하는 것이 쉽습니다.
- 최대한 제한이 되어 있어야 변경하기 쉽습니다.
- 클래스의 상태를 나타내는 프로퍼티가 노출되어 있다면, 클래스가 자신의 상태를 책임질 수 없습니다.
- 가시성이 제한되면 API의 변경을 쉽게 추적할 수 있습니다.