# 아이템 4. inferred 타입으로 리턴하지 말라

코틀린의 <b>타입 추론<small>(type inference)</small></b>은 JVM 세계에서 가장 널리 알려진 코틀린의 특징이며, 자바도 자바10부터는 코틀린을 따라 타입 추론을 도입했습니다<small>(코틀린과 비교하면 몇 가지 제약이 존재)</small>.

다만 타입 추론을 사용할 때는 몇 가지 위험한 부분들이 있습니다. 이러한 위험한 부분을 피하려면, 우선 할당 때 inferred 타입은 정확하게 오른쪽에 있는 피연사자에 맞게 설정된다는 것을 기억해야 합니다. **절대로 슈퍼클래스 또는 인터페이스로는 설정되지 않습니다.**

```kotlin
open class Animal
class Zebra: Animal()

fun main() {
    var animal = Zebra()
    animal = Animal() // 오류 : Type mismatch
}
```

일반적인 경우에는 이러한 것이 문제가 되지 않습니다. 그냥 원하는 타입보다 제한된 타입이 설정되어 있다면 타입을 명시적으로 지정해서 해결하면 됩니다.

```kotlin
open class Animal
class Zebra: Animal()

fun main() {
    var animal: Animal = Zebra()
    animal = Animal()
}
```

<b>하지만 직접 라이브러리(또는 모듈)를 조작할 수 없는 경우에는 이러한 문제를 간단하게 해결할 수 없습니다.</b> 그리고 이러한 경우에서 inferred 타입을 노출하면 위험한 일이 발생할 수 있습니다. 간단한 예제를 살펴봅시다.

다음과 같은 CarFactory 인터페이스가 있다고 해 봅시다.

```kotlin
interface CarFactory {
    fun produce(): Car
}
```

또한 다른 것을 지정하지 않았을 경우, 다음과 같이 디폴트로 생성되는 자동차가 있다고 해 봅시다.

```kotlin
val DEFAULT_CAR: Car = Fiat126P() // Fiat 126P는 1972년에 출시된 자동차
```

코드를 작성하다 보니 `DEFAULT_CAR`는 `Car`로 명시적으로 지정되어 있으므로 따로 필요 없다고 판단하여 함수의 리턴 타입을 제거했다고 가정해봅니다.

```kotlin
interface CarFactory {
    fun produce() = Fiat126P()
}
```

그런데 이후에 다른 사람이 코드를 보다가 `DEFAULT_CAR`는 타입 추론에 의해 자동으로 타입이 지정될 것이므로 `Car`를 명시적으로 지정하지 않아도 된다고 생각하여, 다음과 같이 코드를 변경했다고 해 봅시다.

```kotlin
val DEFAULT_CAR = Fiat126P()
```

이렇게 변경이 되면 문제가 발생합니다. `CarFactory`에서는 이제 `Fiat126P` 이외의 자동차를 생산하지 못합니다.

만약 인터페이스를 우리가 직접 만들었다면, 문제를 굉장히 쉽게 찾아서 수정할 수 있을 것입니다. 하지만 외부 API<small>(external API)</small>라면, 문제를 쉽게 해결할 수 없습니다. 다른 사용자가 이런 외부 API를 썼다면, 화를 내면서 문제가 있다고 제작자에게 말하게 될 것입니다.

리턴 타입은 API를 잘 모르는 사람에게 전달해 줄 수 있는 중요한 정보입니다. 따라서 **리턴 타입은 외부에서 확인할 수 있게 명시적으로 지정해 주는 것이 좋습니다.**

## 정리

타입을 확실하게 지정해야 하는 경우에는 명시적으로 타입을 지정해야 한다는 원칙만 가지고 있으면 됩니다. 이는 굉장히 중요한 정보이므로, 숨기지 않는 것이 좋습니다<small>(`아이템 14: 타입이 명확하게 보이지 않는 경우 확실하게 지정하라`에서 자세히 설명)</small>. 또한 안전을 위해서 외부 API를 만들 때는 반드시 타입을 지정하고, 이렇게 지정한 타입을 특별한 이유와 확실한 확인 없이는 제거하지 말기 바랍니다. inferred 타입은 프로젝트가 진전될 때, 제한이 너무 많아지거나 예측하지 못한 결과를 낼 수도 있다는 것을 기억하세요.